{
    "contents" : "\n# Funciones auxiliares ----------------------------------------------------\n\n# Ver el tamaño de los objetos en el workspace, en MB\nlh <- function(qqq){\n  # Pasarle ls(). Regresa los tamanios en mb\n  a <- sapply(qqq, function(x) eval(parse(text = paste0('object.size(',x,')')))) %>%\n    data.frame\n  names(a) <- 'b'\n  a$mb <- format(round(a$b/2^20, 1), )\n  a\n}\n\n# Imagen de matriz bien rotada\nmat_image <- function(mat, ...){\n  mat %>%\n    apply(2, rev) %>%\n    t %>%\n    image(...)\n}\n\n# Transforma de grados a radianes\ndeg2rad <- function(deg) return(deg*pi/180)\n\n# Calculates the geodesic distance between two points specified by radian latitude/longitude using the\n# Haversine formula (hf)\ngeodesic_distance <- function(long1, lat1, long2, lat2, units = 'deg') {\n  if(any(is.na(c(long1,lat1,long2,lat2)))){\n    return(Inf)\n  } else {\n    if(units == 'deg'){\n      long1 <- deg2rad(long1)\n      lat1 <- deg2rad(lat1)\n      long2 <- deg2rad(long2)\n      lat2 <- deg2rad(lat2)\n    }\n    R <- 6371 # Earth mean radius [km]\n    delta.long <- (long2 - long1)\n    delta.lat <- (lat2 - lat1)\n    a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2\n    #   c <- 2 * asin(min(1,sqrt(a)))\n    # el ifelse es 7 veces más rápido que sapply...\n    c <- 2 * asin(ifelse(a > 1, 1, sqrt(a))) #asin(sapply(a, function(x) min(1,sqrt(x))))\n    d = R * c\n    return(d) # Distance in km\n  }\n}\n\n##### Función auxiliar para graficar circulos\ngenerate_circle <- function(center = c(0,0), radius = 1, npoints = 100){\n  r = radius\n  tt <- seq(0,2*pi,length.out = npoints)\n  xx <- center[1] + r * cos(tt)\n  yy <- center[2] + r * sin(tt)\n  return(data.frame(x = xx, y = yy))\n}\n\n##### Calcula el radio para generar un circulo de ciertos km de radio\ncalculate_radius <- function(long, lat, km, precision = 10000, maxdeg = 2){\n  dtheta <- seq(0,maxdeg,l=precision)\n  y <- sapply(dtheta, function(i){\n    geodesic_distance(long,lat,long,lat+i,units='deg')\n  })\n  dtheta[y > km][1]\n}\n\n##### Función para filtrar hoteles lejanos y caros\nfiltra_cand <- function(clav,\n                        hot,\n                        price_range=0.3,\n                        outer_fence=50,\n                        min_num_recom=10){\n  long1 <- hot %>% filter(ID_Hotel == clav) %>% .$longitude\n  lat1 <- hot %>% filter(ID_Hotel == clav) %>% .$latitude\n  p1 <- hot %>% filter(ID_Hotel == clav) %>% .$Precio_Dlls\n  p1 <- ifelse(is.na(p1), Inf, p1) # Si no hay precio, ignoramos el criterio haciendo que cueste infinito\n  aux1 <- hot %>%\n    mutate(km = geodesic_distance(long1, lat1, longitude, latitude, units = 'deg'),\n           ### Sin el ifelse es mucho mas rapido. Requiere informacion limpia\n           #ifelse(is.na(latitude) | is.na(longitude), Inf,\n                 #      geodesic_distance(long1, lat1, longitude, latitude, units = 'deg')),\n           precio = ifelse(is.na(Precio_Dlls), Inf, Precio_Dlls)) %>%\n    dplyr::select(ID_Hotel, precio, km)\n  precio_idx <- (aux1$precio < (1 + price_range)*p1)\n  outer_fence_idx <- (aux1$km <= outer_fence)\n  if(sum(precio_idx & outer_fence_idx) >= 10){ # Hay suficientes hoteles cerca en el rango de precios\n    out_idx <- (precio_idx & outer_fence_idx)\n    flag <- 'dist & price'\n  } else if(sum(outer_fence_idx) >= 10){       # No hay suficientes --> Relajamos el precio\n    out_idx <- outer_fence_idx\n    flag <- 'dist'\n  } else {                                   # Aún no hay suficientes --> Tomamos los más cercanos\n    out_idx_aux <- order(aux1$km) %>% head(min_num_recom)\n    out_idx <- rep(FALSE, nrow(hot))\n    out_idx[out_idx_aux] <- TRUE\n    flag <- paste('n closest')\n  }\n  cand <- data.frame(id1=clav, id2=hot$ID_Hotel, km=aux1$km, p1=p1, p2=aux1$precio)\n  output <- list(cand=cand,\n                 precio_idx=precio_idx,\n                 outer_fence_idx=outer_fence_idx,\n                 out_idx=out_idx,\n                 price_range=price_range,\n                 outer_fence=outer_fence,\n                 min_num_recom=min_num_recom,\n                 type=flag)\n  return(output)\n}\n\n##### Función para calcular similitudes\ncalcula_sim <- function(candidatos, mat, mat_norm){\n  # candidatos es una matriz de nx2, con #candidato 1, #candidato 2\n  # mat es la matriz categorias-hoteles\n  # mat_norm es mat pero normalizada a que cada hotel sume 1\n  \n  candidatos <- as.matrix(candidatos)\n  if(nrow(candidatos) == 0){\n    return(NULL)\n  }\n  \n  # Resta matriz cantidades\n  subst <- mat[,candidatos[,1]] - mat[,candidatos[,2]]\n  if(length(subst@x) != 0){\n    auxm <- subst\n    auxm@x <- ifelse(subst@x > 0, subst@x, 0) ###sapply(subst@x, function(x) max(x,0))\n    hinge <- colSums(auxm) %>% as.numeric\n    auxm@x <- abs(subst@x) ###sapply(subst@x, function(x) abs(x))\n    abs <- colSums(auxm) %>% as.numeric\n    \n    # Resta matriz normalizada\n    subst <- mat_norm[,candidatos[,1]] - mat_norm[,candidatos[,2]]\n    auxm@x <- abs(subst@x)/2 ###sapply(subst@x, function(x) abs(x)/2)\n    diverg <- colSums(auxm) %>% as.numeric\n  } else { # Tanto el query como los candidatos tienen cero servicios\n    hinge <- rep(0, ncol(subst))\n    abs <- hinge\n    diverg <- hinge\n  }\n  \n  distancias <- data.frame(diverg=diverg, diff_features=abs, hinge=hinge)\n\n  output <- cbind(candidatos[,1:2], distancias)\n  names(output) <- c('id1','id2','diverg','diff_features','hinge')\n  \n  output\n}\n",
    "created" : 1436543552674.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "4|20|11|0|\n14|32|19|0|\n26|72|46|0|\n49|72|55|0|\n58|75|64|0|\n71|42|107|0|\n110|51|145|0|\n",
    "hash" : "1806873666",
    "id" : "3C3DD0D3",
    "lastKnownWriteTime" : 1436467783,
    "path" : "~/recomendacion_de_hoteles/codigo/funciones.R",
    "project_path" : "codigo/funciones.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}