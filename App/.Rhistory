ls(
)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
#library(parallel) # No funciona en windows
library(foreach)
#library(doSNOW)
library(Matrix)
library(ggmap)
options(scipen = 10) # Solo los numeros grandes en notacion cientifica
lh <- function(qqq){
# Pasarle ls(). Regresa los tamanios en mb
a <- sapply(qqq, function(x) eval(parse(text = paste0('object.size(',x,')')))) %>%
data.frame
names(a) <- 'b'
a$mb <- format(round(a$b/2^20, 1), )
a
}
# Imagen de matriz bien rotada
mat_image <- function(mat, ...){
mat %>%
apply(2, rev) %>%
t %>%
image(...)
}
# Transforma de grados a radianes
deg2rad <- function(deg) return(deg*pi/180)
# Calculates the geodesic distance between two points specified by radian latitude/longitude using the
# Haversine formula (hf)
geodesic_distance <- function(long1, lat1, long2, lat2, units = 'deg') {
if(units == 'deg'){
long1 <- deg2rad(long1)
lat1 <- deg2rad(lat1)
long2 <- deg2rad(long2)
lat2 <- deg2rad(lat2)
}
R <- 6371 # Earth mean radius [km]
delta.long <- (long2 - long1)
delta.lat <- (lat2 - lat1)
a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2
#   c <- 2 * asin(min(1,sqrt(a)))
c <- 2 * asin(sapply(a, function(x) min(1,sqrt(x))))
d = R * c
return(d) # Distance in km
}
##### FunciÃ³n para calcular similitudes
calcula_sim <- function(candidatos, mat, nbatch=10, outvar='sim', normalization='cos'){
# candidatos es una matriz de nx2, con #candidato 1, #candidato
# mat es la matriz servicios-hoteles
# nbatch es el nÃºmero de cachos en los que se partirÃ¡ la matriz para realizar la operaciÃ³n
# outvar es el tipo de variable, 'sim', 'cos', 'rad' o 'all'.
# normalization 'cos', 'jaccard', 'jaccard2', 'hinge', 'mix'
# OJO: 'jaccard2' NO es una distancia porque tiene lado. Normaliza con el del lado izquierdo.
m <- nrow(candidatos)
###### OJO se puede comer algunos con el redondeo
aux <- floor(seq(1, m, l=nbatch+1))
print(aux)
if(normalization == 'cos'){
norms <- mat^2 %>%
colSums %>%
sqrt
cos.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Coseno del angulo verdadero
prod_norms <- (norms[candidatos[ini:fin,1]] * norms[candidatos[ini:fin,2]])
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / prod_norms %>%
as.numeric
}) %>%
unlist
cos.cand <- sapply(cos.cand, function(x) ifelse(x >= 0, min(x,1), max(x,-1)))
if(outvar=='sim'){
output <- data.frame(candidatos[,1:2], sim = 1 - acos(cos.cand)/pi)
names(output) <- c('id1','id2','sim')
}else if(outvar=='cos'){
output <- data.frame(candidatos[,1:2], cos = cos.cand)
names(output) <- c('id1','id2','cos')
}else if(outvar=='rad'){
output <- data.frame(candidatos[,1:2], rad = acos(cos.cand))
names(output) <- c('id1','id2','rad')
}else{
output <- data.frame(candidatos[,1:2],
sim = 1 - acos(cos.cand)/pi,
cos = cos.cand,
rad = acos(cos.cand))
names(output) <- c('id1','id2','sim','cos','rad')
}
}else if(normalization == 'jaccard'){
sim.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
norms <- mat[,candidatos[ini:fin,1]] + mat[,candidatos[ini:fin,2]]
norms@x <- as.numeric(norms@x > 0)
deno <- colSums(norms)
# Similitud de Jaccard
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / deno %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], sim = sim.cand)
names(output) <- c('id1','id2','sim')
}else if(normalization == 'jaccard2'){
sim.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
norms <- mat[,candidatos[ini:fin,1]]
norms@x <- as.numeric(norms@x > 0)
deno <- colSums(norms)
# Similitud de Jaccard asimetrica
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / deno %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], sim = sim.cand)
names(output) <- c('id1','id2','sim')
}else if(normalization == 'hinge'){
dist.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) max(x,0))
colSums(subst) %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], dist = dist.cand)
names(output) <- c('id1','id2','dist')
}else if(normalization == 'mix'){
dist.cand.hinge <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) max(x,0))
colSums(subst) %>%
as.numeric
}) %>%
unlist
dist.cand.abs <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) abs(x))
colSums(subst) %>%
as.numeric
}) %>%
unlist
sums <- colSums(mat)
mat_norm <- sparseMatrix(i = summary(mat)$i,
j = summary(mat)$j,
x = mat@x/sums[summary(mat)$j])
dist.cand.rel.abs <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en valor absoluto
subst <- mat_norm[,candidatos[ini:fin,1]] - mat_norm[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) abs(x)/2) # Dividimos entre dos para que estÃ© entre 0 y 1
colSums(subst) %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], diverg = dist.cand.rel.abs, diff_features = dist.cand.abs, hinge = dist.cand.hinge)
names(output) <- c('id1','id2','diverg','diff_features','hinge')
}
output
}
load('datos/hoteles_servicios_mex.Rdata')
# Categorias
load('datos/hoteles_servicios_categorias_mex.Rdata')
# Precios, comentarios, geolocalizacion
load('datos/hoteles_precios_comentarios_geo_mex.Rdata')
getwd()
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
shiny::runApp('recomendacion_de_hoteles/App')
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggthemes)
library(foreach)
library(Matrix)
library(ggmap)
####################################### lectura del diccionario y la matriz tdm #########################################
setwd("C:/Users/bmxddt005062/Documents/recomendacion_de_hoteles/App")
options(scipen = 10) # Solo los numeros grandes en notacion cientifica
# Imagen de matriz bien rotada
mat_image <- function(mat, ...){
mat %>%
apply(2, rev) %>%
t %>%
image(...)
}
# Transforma de grados a radianes
deg2rad <- function(deg) return(deg*pi/180)
# Calculates the geodesic distance between two points specified by radian latitude/longitude using the
# Haversine formula (hf)
geodesic_distance <- function(long1, lat1, long2, lat2, units = 'deg') {
if(units == 'deg'){
long1 <- deg2rad(long1)
lat1 <- deg2rad(lat1)
long2 <- deg2rad(long2)
lat2 <- deg2rad(lat2)
}
R <- 6371 # Earth mean radius [km]
delta.long <- (long2 - long1)
delta.lat <- (lat2 - lat1)
a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2
#   c <- 2 * asin(min(1,sqrt(a)))
c <- 2 * asin(sapply(a, function(x) min(1,sqrt(x))))
d = R * c
return(d) # Distance in km
}
##### FunciÃƒÂ³n auxiliar para graficar cÃƒ­rculos
generate_circle <- function(center = c(0,0), radius = 1, npoints = 100){
r = radius
tt <- seq(0,2*pi,length.out = npoints)
xx <- center[1] + r * cos(tt)
yy <- center[2] + r * sin(tt)
return(data.frame(x = xx, y = yy))
}
##### Calcula el radio para generar un cÃƒ­rculo de ciertos km de radio
calculate_radius <- function(long, lat, km, precision = 100, maxdeg = 2){
dtheta <- seq(0,maxdeg,l=precision)
y <- sapply(dtheta, function(i){
geodesic_distance(long,lat,long,lat+i,units='deg')
})
dtheta[y > km][1]
}
##### FunciÃƒÂ³n para calcular similitudes
calcula_sim <- function(candidatos, mat, nbatch=10, outvar='sim', normalization='cos'){
# candidatos es una matriz de nx2, con #candidato 1, #candidato
# mat es la matriz servicios-hoteles
# nbatch es el nÃƒÂºmero de cachos en los que se partirÃƒÂ¡ la matriz para realizar la operaciÃƒÂ³n
# outvar es el tipo de variable, 'sim', 'cos', 'rad' o 'all'.
# normalization 'cos', 'jaccard', 'jaccard2', 'hinge', 'mix'
# OJO: 'jaccard2' NO es una distancia porque tiene lado. Normaliza con el del lado izquierdo.
m <- nrow(candidatos)
###### OJO se puede comer algunos con el redondeo
aux <- floor(seq(1, m, l=nbatch+1))
print(aux)
if(normalization == 'cos'){
norms <- mat^2 %>%
colSums %>%
sqrt
cos.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Coseno del angulo verdadero
prod_norms <- (norms[candidatos[ini:fin,1]] * norms[candidatos[ini:fin,2]])
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / prod_norms %>%
as.numeric
}) %>%
unlist
cos.cand <- sapply(cos.cand, function(x) ifelse(x >= 0, min(x,1), max(x,-1)))
if(outvar=='sim'){
output <- data.frame(candidatos[,1:2], sim = 1 - acos(cos.cand)/pi)
names(output) <- c('id1','id2','sim')
}else if(outvar=='cos'){
output <- data.frame(candidatos[,1:2], cos = cos.cand)
names(output) <- c('id1','id2','cos')
}else if(outvar=='rad'){
output <- data.frame(candidatos[,1:2], rad = acos(cos.cand))
names(output) <- c('id1','id2','rad')
}else{
output <- data.frame(candidatos[,1:2],
sim = 1 - acos(cos.cand)/pi,
cos = cos.cand,
rad = acos(cos.cand))
names(output) <- c('id1','id2','sim','cos','rad')
}
}else if(normalization == 'jaccard'){
sim.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
norms <- mat[,candidatos[ini:fin,1]] + mat[,candidatos[ini:fin,2]]
norms@x <- as.numeric(norms@x > 0)
deno <- colSums(norms)
# Similitud de Jaccard
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / deno %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], sim = sim.cand)
names(output) <- c('id1','id2','sim')
}else if(normalization == 'jaccard2'){
sim.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
norms <- mat[,candidatos[ini:fin,1]]
norms@x <- as.numeric(norms@x > 0)
deno <- colSums(norms)
# Similitud de Jaccard asimetrica
colSums(mat[,candidatos[ini:fin,1]] * mat[,candidatos[ini:fin,2]]) / deno %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], sim = sim.cand)
names(output) <- c('id1','id2','sim')
}else if(normalization == 'hinge'){
dist.cand <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) max(x,0))
colSums(subst) %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], dist = dist.cand)
names(output) <- c('id1','id2','dist')
}else if(normalization == 'mix'){
dist.cand.hinge <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) max(x,0))
colSums(subst) %>%
as.numeric
}) %>%
unlist
dist.cand.abs <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en hinge loss
subst <- mat[,candidatos[ini:fin,1]] - mat[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) abs(x))
colSums(subst) %>%
as.numeric
}) %>%
unlist
sums <- colSums(mat)
mat_norm <- sparseMatrix(i = summary(mat)$i,
j = summary(mat)$j,
x = mat@x/sums[summary(mat)$j])
dist.cand.rel.abs <- lapply(1:nbatch, function(i){
print(i)
ini <- ifelse(aux[i] == 1, 1, aux[i] + 1)
fin <- aux[i+1]
# Distancia basada en valor absoluto
subst <- mat_norm[,candidatos[ini:fin,1]] - mat_norm[,candidatos[ini:fin,2]]
subst@x <- sapply(subst@x, function(x) abs(x)/2) # Dividimos entre dos para que estÃƒÂ© entre 0 y 1
colSums(subst) %>%
as.numeric
}) %>%
unlist
output <- data.frame(candidatos[,1:2], diverg = dist.cand.rel.abs, diff_features = dist.cand.abs, hinge = dist.cand.hinge)
names(output) <- c('id1','id2','diverg','diff_features','hinge')
}
output
}
# Servicios
load('../datos/hoteles_servicios_mex.Rdata')
# Categorias
load('../datos/hoteles_servicios_categorias_mex.Rdata')
# Precios, comentarios, geolocalizacion
load('../datos/hoteles_precios_comentarios_geo_mex.Rdata')
filter(claves_hoteles, grepl(input$hotel, Nombre_Hotel))$ID_Hotel[1]
filter(claves_hoteles, grepl('Now Sapp', Nombre_Hotel))$ID_Hotel[1]
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
a1 <- hoteles %>%
dplyr::select(id1=ID_Hotel, n1=Nombre_Hotel, cl1=Clav_Hotel, cal1=Calificacion,
com1=Total_Comentarios, p1=Precio_Dlls, u1=Utilidad_Dlls, range1=Date_Range,
pais1=Nombre_Pais, est1=Nombre_Estado, zip1=Codigo_Postal, stars1=Clav_Categoria,
dest1=Clav_Destino, ubic1=Clav_Ubicacion, long1=longitude, lat1=latitude)
a2 <- hoteles %>%
dplyr::select(id2=ID_Hotel, n2=Nombre_Hotel, cl2=Clav_Hotel, cal2=Calificacion,
com2=Total_Comentarios, p2=Precio_Dlls, u2=Utilidad_Dlls, range2=Date_Range,
pais2=Nombre_Pais, est2=Nombre_Estado, zip2=Codigo_Postal, stars2=Clav_Categoria,
dest2=Clav_Destino, ubic2=Clav_Ubicacion, long2=longitude, lat2=latitude)
top <- salida() %>%
left_join(a1) %>%
left_join(a2) %>%
mutate(km = geodesic_distance(long1,lat1,long2,lat2,units = 'deg'),
hinge_norm = hinge/nserv) %>%
dplyr::select(id1,id2,n1,n2,diverg,diff_features,hinge,hinge_norm,p1,p2,cal1,cal2,km,u1,u2,dest1,dest2,stars1,stars2,com1,com2,est1,est2,ubic1,ubic2,cl1,cl2,range1,range2,long1,lat1,long2,lat2,pais1,pais2)
a1
a2
salida %>%
left_join(a1) %>%
left_join(a2) %>%
mutate(km = geodesic_distance(long1,lat1,long2,lat2,units = 'deg'),
hinge_norm = hinge/nserv) %>%
dplyr::select(id1,id2,n1,n2,diverg,diff_features,hinge,hinge_norm,p1,p2,cal1,cal2,km,u1,u2,dest1,dest2,stars1,stars2,com1,com2,est1,est2,ubic1,ubic2,cl1,cl2,range1,range2,long1,lat1,long2,lat2,pais1,pais2)
salida <- calcula_sim(cand(), mat = categ_sparse_cant, nbatch = 1, normalization = 'mix') %>%
mutate(diverg = round(diverg, 3))
cand <- data.frame(id1=clav(), id2=claves_hoteles$ID_Hotel)
shiny::runApp()
shiny::runApp()
loc
loc(
)
renderText(loc())
clav
renderText(clav())
renderText(clav())()
renderText(clav())
a1
a2
top
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
